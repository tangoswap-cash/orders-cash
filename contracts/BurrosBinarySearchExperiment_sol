// SPDX-License-Identifier: Apache
pragma solidity 0.8.10;

import "@openzeppelin/contracts/access/Ownable.sol";
// import "@openzeppelin/contracts/utils/math/SafeMath.sol";
// import "./UniversalERC20.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "hardhat/console.sol";

interface ISmartSwapRewarder {
    function getExpectedReturn(IERC20 fromToken,IERC20 destToken,uint256 amount,uint256 parts,uint256 flags) external view returns(uint256 returnAmount, uint256[] memory distribution);
}

contract Burros is Ownable {
    // using SafeMath for uint256;
    // using UniversalERC20 for IERC20;

    address private constant SEP206Addr = 0x0000000000000000000000000000000000002711;
    address private constant BCH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    address private constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;

    address private constant SMARTSWAP_ADDRESS = 0xEd2E356C00A555DDdd7663BDA822C6acB34Ce614;

    string private constant EIP712_DOMAIN = "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)";
    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(EIP712_DOMAIN));
    bytes32 private constant NAME_HASH = keccak256(abi.encodePacked("exchange dapp"));
    bytes32 private constant VERSION_HASH = keccak256(abi.encodePacked("v0.1.0"));
    uint256 private constant CHAINID = 10000; // smartBCH mainnet
    bytes32 private constant SALT = keccak256(abi.encodePacked("Exchange"));

    bytes32 private constant TYPE_HASH =
        keccak256(abi.encodePacked("Exchange(uint256 coinsToMaker,uint256 coinsToTaker,uint256 dueTime80)"));

    uint256 private constant MUL = 10**12; // number of picoseconds in one second
    uint256 private constant MaxClearCount = 10;

    uint256 public smartSwapFeePercent;

    //To prevent replay of coin-exchanging messages, we use dueTime to identify a coin-exchanging message uniquely
    mapping(address => mapping(uint256 => uint256)) public makerNextRecentDueTime; //the pointers of a linked-list
    mapping(address => uint256) public makerRDTHeadTail; //the head and tail of a linked-list

    //A maker and a taker exchange their coins
    event Exchange(address indexed maker, address indexed taker, address coinTypeToMaker, uint256 coinAmountToMaker, address coinTypeToTaker, uint256 coinAmountToTaker, uint256 dueTime80);

    event SmartSwapFeePercentUpdated(uint256 feePercent);

    constructor(uint256 _feePercent) public {
        setSmartSwapFeePercent(_feePercent);
    }

    function setSmartSwapFeePercent(uint256 _feePercent) public onlyOwner {
        require(_feePercent >= 0 && _feePercent <= 0.03e18, "Burros: SmartSwap feePercent out of range");
        smartSwapFeePercent = _feePercent;
        emit SmartSwapFeePercentUpdated(_feePercent);
    }

    function smartBCH() internal pure returns(ISmartSwapRewarder) {
        return ISmartSwapRewarder(SMARTSWAP_ADDRESS);
    }

    function isBCH(address tokenAddr) internal pure returns(bool) {
        return (tokenAddr == ZERO_ADDRESS || tokenAddr == BCH_ADDRESS || tokenAddr == SEP206Addr);
    }

    function getEIP712Hash(
        uint256 coinsToMaker,
        uint256 coinsToTaker,
        uint256 dueTime80
    ) public view returns (bytes32) {
        bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712_DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH, CHAINID, address(this), SALT));
        return
            keccak256(
                abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, keccak256(abi.encode(TYPE_HASH, coinsToMaker, coinsToTaker, dueTime80)))
            );
    }

    // ** La usa el Taker
    function getSigner(
        uint256 coinsToMaker,
        uint256 coinsToTaker,
        uint256 dueTime80_v8,
        bytes32 r,
        bytes32 s
    ) public view returns (address) {
        bytes32 eip712Hash = getEIP712Hash(coinsToMaker, coinsToTaker, dueTime80_v8 >> 8);
        uint8 v = uint8(dueTime80_v8); //the lowest byte is v
        return ecrecover(eip712Hash, v, r, s);
    }

    // ** No encuentro uso
    // Returns recent recorded dueTimes of a maker
    function getRecentDueTimes(address makerAddr, uint256 maxCount) external view returns (uint256[] memory) {
        uint256 head = makerRDTHeadTail[makerAddr] >> 80;
        uint256[] memory recentDueTimes = new uint256[](maxCount);
        for (uint256 i = 0; i < maxCount && head != 0; ++i) {
            recentDueTimes[i] = head;
            head = makerNextRecentDueTime[makerAddr][head];
        }
        return recentDueTimes;
    }

    // ** Se usa para que el Maker cancele su propia orden
    // By adding a new dueTime entry in the linked-list, we can revoke a coin-exchanging message
    function addNewDueTime(uint256 newDueTime) external {
        require(newDueTime != 0, "Burros: invalid dueTime");
        uint256 currTime = block.timestamp * MUL;
        clearOldDueTimesAndInsertNew(msg.sender, newDueTime, currTime);
    }

    // ** No encuentro uso
    // Delete some useless entries from the linked list
    function clearOldDueTimes(uint256 maxCount, address makerAddr) external {
        uint256 currTime = block.timestamp * MUL;
        uint256 headTail = makerRDTHeadTail[makerAddr];
        (uint256 head, uint256 tail) = (headTail >> 80, uint256(uint80(headTail)));
        (head, tail) = _clearOldDueTimes(maxCount, makerAddr, currTime, head, tail);
        makerRDTHeadTail[makerAddr] = (head << 80) | tail;
    }

    // ** La usa el Taker
    // If a message's dueTime was recorded in the linked-list before, it is a replay and can't take effect
    function isReplay(address makerAddr, uint256 dueTime) external view returns (bool) {
        uint256 tail = uint80(makerRDTHeadTail[makerAddr]);
        return tail == dueTime || makerNextRecentDueTime[makerAddr][dueTime] != 0;
    }

    //Delete some useless entries from the linked list and insert a new one
    function clearOldDueTimesAndInsertNew(
        address makerAddr,
        uint256 newDueTime,
        uint256 currTime
    ) private {
        uint256 headTail = makerRDTHeadTail[makerAddr];
        (uint256 head, uint256 tail) = (headTail >> 80, uint256(uint80(headTail)));
        require(tail != newDueTime && makerNextRecentDueTime[makerAddr][newDueTime] == 0, "Burros: dueTime not new");

        (head, tail) = _clearOldDueTimes(MaxClearCount, makerAddr, currTime, head, tail);
        (head, tail) = _addNewDueTime(makerAddr, newDueTime, head, tail);
        makerRDTHeadTail[makerAddr] = (head << 80) | tail;
    }

    // The linked-list:
    // No entries in queue: head = 0, tail = 0
    // One entry in queue: head = dueTime, tail = dueTime
    // Two entries in queue: head = A, tail = B, makerNextRecentDueTime[makerAddr][A] = B
    function _clearOldDueTimes(
        uint256 maxCount,
        address makerAddr,
        uint256 currTime,
        uint256 head,
        uint256 tail
    ) private returns (uint256, uint256) {
        for (uint256 i = 0; i < maxCount && head < currTime && head != 0; ++i) {
            uint256 newHead = makerNextRecentDueTime[makerAddr][head];
            makerNextRecentDueTime[makerAddr][head] = 0;
            head = newHead;
        }

        if (head == 0) {
            tail = 0;
        }

        return (head, tail);
    }

    function _addNewDueTime(
        address makerAddr,
        uint256 dueTime,
        uint256 head,
        uint256 tail
    ) private returns (uint256, uint256) {
        if (head == 0) {
            return (dueTime, dueTime);
        }

        makerNextRecentDueTime[makerAddr][tail] = dueTime;
        return (head, dueTime);
    }

    // A taker exchanges with a maker, using a message signature generated by the maker
    function directExchange(
        uint256 coinsToMaker,
        uint256 coinsToTaker,
        uint256 dueTime80_v8,
        bytes32 r,
        bytes32 s
    ) external payable {
        _directExchange(coinsToMaker, coinsToTaker, dueTime80_v8, r, s);
    }

    // TODO
    function smartExchange(
        address fromToken,
        uint256 coinsToMaker,
        uint256 coinsToTaker,
        uint256 dueTime80_v8,
        bytes32 r,
        bytes32 s
    ) external payable {
        _smartExchange(fromToken, coinsToMaker, coinsToTaker, dueTime80_v8, r, s);
    }

    function _directExchange(
        uint256 coinsToMaker,
        uint256 coinsToTaker,
        uint256 dueTime80_v8,
        bytes32 r,
        bytes32 s
    ) private {
        uint256 dueTime = uint80(dueTime80_v8 >> 8);
        uint256 currTime = block.timestamp * MUL;
        require(currTime < dueTime, "Burros: order expired");

        address makerAddr = getSigner(coinsToMaker, coinsToTaker, dueTime80_v8, r, s);

        clearOldDueTimesAndInsertNew(makerAddr, dueTime, currTime);
        address takerAddr = msg.sender;

        address coinTypeToMaker = address(bytes20(uint160(coinsToMaker >> 96)));
        uint256 coinAmountToMaker = uint256(uint96(coinsToMaker));
        address coinTypeToTaker = address(bytes20(uint160(coinsToTaker >> 96)));
        uint256 coinAmountToTaker = uint256(uint96(coinsToTaker));

        require( ! isBCH(coinTypeToMaker), "Burros: BCH is not allowed");
        require( ! isBCH(coinTypeToTaker), "Burros: BCH is not allowed");

        emit Exchange(makerAddr, takerAddr, coinTypeToMaker, coinAmountToMaker, coinTypeToTaker, coinAmountToTaker, dueTime);

        if (coinAmountToTaker != 0) {
            (bool success, bytes memory _notUsed) = coinTypeToTaker.call(
                abi.encodeWithSignature("transferFrom(address,address,uint256)", makerAddr, takerAddr, coinAmountToTaker)
            );
            require(success, "Burros: transferFrom failed");
        }

        if (coinAmountToMaker != 0) {
            require(msg.value == 0, "Burros: no need for BCH");
            IERC20(coinTypeToMaker).transferFrom(takerAddr, makerAddr, coinAmountToMaker);
        }
    }

    // template<class ForwardIt, class T>
    // ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value)
    // {
    //     ForwardIt it;
    //     typename std::iterator_traits<ForwardIt>::difference_type count, step;
    //     count = std::distance(first, last);

    //     while (count > 0) {
    //         it = first;
    //         step = count / 2;
    //         std::advance(it, step);
    //         if (*it < value) {
    //             first = ++it;
    //             count -= step + 1;
    //         }
    //         else
    //             count = step;
    //     }
    //     return first;
    // }


    // function smartBCH() internal pure returns(uint256) {
    //     return ISmartSwapRewarder(SMARTSWAP_ADDRESS);
    // }

    // function lower_bound(IERC20 fromToken, IERC20 toToken, uint256 first, uint256 last, uint256 value) internal pure returns(uint256) {
    //     // ForwardIt it;
    //     // typename std::iterator_traits<ForwardIt>::difference_type count, step;
    //     uint256 it;
    //     uint256 diff = last - first;

    //     while (diff > 0) {
    //         it = first;
    //         step = diff / 2;
    //         it += step;

    //         uint256 returnAmount;
    //         uint256[] memory distribution;
    //         (returnAmount, distribution) = smartBCH().getExpectedReturn(
    //             fromToken,
    //             toToken,
    //             it,
    //             10,
    //             0
    //         );
    //         console.log("lower_bound returnAmount: ");
    //         console.log(returnAmount);


    //         if (*it < value) {
    //             first = ++it;
    //             diff -= step + 1;
    //         } else {
    //             diff = step;
    //         }
    //     }
    //     return first;
    // }

    // function partition_point_n(f, n, p) {
    //     while (n != 0) {
    //         var h = half_nonnegative(n);
    //         var m = successor(f, h);

    //         if (p(source(m))) {
    //             n = h;
    //         } else {
    //             n -= h + 1;
    //             f = successor(m);
    //         }
    //     }
    //     return f;
    // }


    function lowerBound(IERC20 fromToken, IERC20 toToken, uint256 first, uint256 last, uint256 value) internal view returns(uint256) {
        // ForwardIt it;
        // typename std::iterator_traits<ForwardIt>::difference_type count, step;
        uint256 diff = last - first;

        while (diff > 0) {
            uint256 half = diff / 2;
            // it += half;
            uint256 it = first + half;

            uint256 returnAmount;
            uint256[] memory distribution;
            (returnAmount, distribution) = smartBCH().getExpectedReturn(
                fromToken,
                toToken,
                it,
                10,
                0
            );
            console.log("lowerBound returnAmount: ");
            console.log(returnAmount);

            if (returnAmount < value) {
                first = it; //++it;
                diff -= half;   //half + 1;
            } else {
                diff = half;
            }
        }
        return first;
    }
    function _smartExchange(
        address fromToken,
        uint256 coinsToMaker,
        uint256 coinsToTaker,
        uint256 dueTime80_v8,
        bytes32 r,
        bytes32 s
    ) private {
        uint256 dueTime = uint80(dueTime80_v8 >> 8);
        uint256 currTime = block.timestamp * MUL;
        require(currTime < dueTime, "Burros: order expired");

        address makerAddr = getSigner(coinsToMaker, coinsToTaker, dueTime80_v8, r, s);

        clearOldDueTimesAndInsertNew(makerAddr, dueTime, currTime);
        address takerAddr = msg.sender;

        address coinTypeToMaker = address(bytes20(uint160(coinsToMaker >> 96)));
        uint256 coinAmountToMaker = uint256(uint96(coinsToMaker));
        address coinTypeToTaker = address(bytes20(uint160(coinsToTaker >> 96)));
        uint256 coinAmountToTaker = uint256(uint96(coinsToTaker));

        require( ! isBCH(coinTypeToMaker), "Burros: BCH is not allowed");
        require( ! isBCH(coinTypeToTaker), "Burros: BCH is not allowed");

        emit Exchange(makerAddr, takerAddr, coinTypeToMaker, coinAmountToMaker, coinTypeToTaker, coinAmountToTaker, dueTime);

        if (coinAmountToTaker != 0) {
            // uint256 returnAmount0;
            // uint256[] memory distribution;
            // (returnAmount0, distribution) = smartBCH().getExpectedReturn(
            //     IERC20(coinTypeToTaker),
            //     IERC20(coinTypeToMaker),
            //     coinAmountToTaker,
            //     10,
            //     0
            // );
            // console.log("returnAmount0: ");
            // console.log(returnAmount0);

            // uint256 returnAmount1;
            // (returnAmount1, distribution) = smartBCH().getExpectedReturn(
            //     IERC20(coinTypeToTaker),
            //     IERC20(coinTypeToMaker),
            //     coinAmountToTaker,
            //     10,
            //     0
            // );
            // console.log("returnAmount1: ");
            // console.log(returnAmount1);

            uint256 fromBalance = IERC20(fromToken).balanceOf(takerAddr);
            console.log("fromBalance: ");
            console.log(fromBalance);

            uint256 xxx = lowerBound(IERC20(fromToken), IERC20(coinTypeToMaker), 0, fromBalance, uint256 value) internal view returns(uint256) {

            // ---------------------------------------------------------------------
            // (bool success, bytes memory _notUsed) = coinTypeToTaker.call(
            //     abi.encodeWithSignature("transferFrom(address,address,uint256)", makerAddr, takerAddr, coinAmountToTaker)
            // );
            // require(success, "Burros: transferFrom failed");
        }


        // if (coinAmountToMaker != 0) {
        //     require(msg.value == 0, "Burros: no need for BCH");
        //     IERC20(coinTypeToMaker).transferFrom(takerAddr, makerAddr, coinAmountToMaker);
        // }
    }
}
